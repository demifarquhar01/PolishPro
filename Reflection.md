# Reflection on Domain Model and Class Diagram Design for PolishPro: Nail Salon Booking System

Designing the domain model and class diagram for the **PolishPro: Nail Salon Booking System** was a challenging experience. From the very beginning, I faced difficulties identifying the key entities for the system. For task 1, I was asked to focus on selecting 5-7 core entities, but figuring out which ones were absolutely necessary and which could be simplified or left out turned out to be harder than I anticipated. I found myself questioning which entities were fundamental to the business logic and which ones could be discarded to keep things simple. This was a learning moment, as it made me realize how important it is to capture all relevant business processes and how certain seemingly small details can affect the system’s overall functionality.

As I worked through the diagram, I began to realize that I had missed some crucial entities. I hadn’t initially considered adding **Reschedule** and **Cancel** as separate entities, but as I thought more about appointment management, I realized they were essential. After including them, the class diagram felt more complete and reflective of the system’s needs. This experience taught me the importance of revisiting my designs and adjusting them as I discover more about the system’s requirements.

One of the biggest challenges I faced during this process was deciding whether certain elements should be represented as methods or as separate classes. For instance, **Reschedule** and **Cancel** could have been modeled as methods within the **Appointment** class, but I ultimately decided that they should be separate classes. This decision was made because they represent distinct business logic, and by treating them as separate entities, I could better capture the complexity of managing appointment changes. At the time, it felt like a good choice, but it also made me realize how tricky it can be to decide whether something should be a method or an entirely new class.

Abstraction was another area I found challenging. It wasn’t always clear how much detail I needed to include in the diagram. For example, defining the relationship between **Appointment** and **Service**, and how both interacted with **Email Notification**, required careful thought. I needed to make sure these relationships were flexible enough to handle any future changes to the system, but not so abstract that they became difficult to follow or understand. This taught me the importance of balancing flexibility with simplicity in object-oriented design.

Additionally, I had to consider whether to use inheritance or composition in modeling relationships between entities. I initially used inheritance to model the different user roles, like **Client**, **Nail Technician**, and **Salon Owner**, as subclasses of the **User** class. But later, I wondered if composition might have been a better choice, especially for future scalability. I chose inheritance because it seemed like the simplest solution for this project, but I recognize that composition could have offered more flexibility in the long term. This is one of the trade-offs I had to make while designing the system.

One of the other major challenges I faced was ensuring that the class diagram aligned with the **use cases**, **state diagrams**, and **requirements** I had developed earlier in the project. I needed to ensure that the class diagram reflected the relationships and processes described in the use cases, such as how clients book and reschedule appointments, how nail technicians manage their schedules, and how email notifications are handled. The class diagram had to be consistent with the functional requirements I had already defined. Additionally, aligning it with the state diagrams was crucial to ensure that the system’s states and transitions were properly represented within the object-oriented model. Having all the previous diagrams available was extremely helpful in guiding the class diagram's development, as they provided a clearer picture of how entities should interact with each other.

Throughout this process, I also learned the importance of **iterative refinement**. At first, I tried to make a perfect class diagram, but I soon realized that the design had to evolve as I gained more insight into the system’s requirements. Going back and making adjustments—adding new entities, tweaking relationships—was essential to creating an accurate and functional model. I learned that a class diagram isn’t something you create once and forget about; it’s a living document that needs to be refined over time.

I also realized the importance of finding a balance between **abstraction** and **specificity**. While it’s important to create a flexible model that can adapt to changes, it’s equally important to avoid overcomplicating the design. Including entities like **Email Notification**, **Reschedule**, and **Cancel** ensured the system could handle all necessary functionality, but each addition made the diagram more complex. Striking the right balance between flexibility and clarity was definitely one of the key lessons I took away from this experience.

In conclusion, working on the **PolishPro Nail Salon Booking System** class diagram was a challenging but also learning experience. It taught me how to think critically about **object-oriented design** and how to approach problems like abstraction, relationship modeling, and balancing complexity. Through this process, I gained a deeper understanding of how to create scalable and flexible systems.
